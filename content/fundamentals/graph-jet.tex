\section{GraphJet}
\label{sec:GraphJet}
GraphJet is a graph-based system for generating content recommendations in real-time. GraphJet keeps a real-time bipartite interaction graph between users and tweets \cite{sharma2016graphjet}. GraphJet assumes that the entire graph can be held in memory on a single server.

This thesis aims to partition the bipartite graph and distribute the GraphJet recommendation system over several machines. Figure \ref{fig:graphJet-architecture} shows the overall architecture of GraphJet, which is divided into three main modules: a storage engine, a recommendation engine, and an API endpoint. The API endpoint receives the requests and forwards them to the recommendation engine. Afterward, the recommendation engine runs an algorithm called SALSA \cite{lempel2001salsa} on the bipartite graph, which the storage engine maintains. Finally, the resulting recommendations are sent back to the requesting user. In the following, we describe each module in more depth.

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.50\textwidth]{images/graphjet/graphJet-architecture}
	\caption{GraphJet overall architecture}
	\label{fig:graphJet-architecture}
\end{figure}


\subsection{Storage Engine}
\label{subsec:GraphJet-Storage-Engine}
The storage engine processes the incoming edges (user-tweet interactions) and maintains the user-tweet interaction bipartite graph in memory. The engine stores the bipartite graph in multiple index segments. At any time, there is only a single mutable (hot) segment and multiple immutable (cold) segments storing the bipartite graph. The mutable index segment is written optimized for fast inserts. 

GraphJet optimizes mutable segments once they reach their capacity limit. Entire segments are copied into a new, immutable segment. Vertices are sorted in read-optimized immutable segments, while all write operations are directed to a new, empty mutable segment.

Since GraphJet is running on a single instance, the size of the graph is limited by the size of the machine's main memory. When that memory limit is reached, the old index segments are deleted and replaced by new ones. Precisely, GraphJet maintains a bipartite graph that keeps track of userâ€“tweet interactions over a window of the last \textit{n} hours.

\subsection{Recommendation Engine}
\label{subsec:GraphJet-Recommendation-Engine}
GraphJet uses the idea behind an algorithm called \emph{SALSA} and optimizes it for its recommendation engine layer. SALSA or Stochastic Approach for Link-Structure Analysis is a web page ranking algorithm created by R. Lempel and S. Moran ~\cite{lempel2001salsa}. In this thesis, we are not focusing on the details of the SALSA algorithm but briefly explains how the main algorithm works. For more information about SALSA, please refer to the main paper ~\cite{lempel2001salsa} and ~\cite{sharma2016graphjet}.

Imagine the following scenario: For a given user \textit{u} we are going to compute the \textit{k} recommendations using SALSA. The random walk starts on the user \textit{u}. From user \textit{u} a random edge (interaction) to a tweet is chosen. Each time SALSA visits a tweet, it increments and keeps the count of the visited tweet. After visiting the tweet and incrementing the visit counter of that tweet, SALSA randomly chooses a user who interacted with that tweet and walks back to the chosen user. This process continues until a specific threshold (number of walks) is reached. SALSA then filters the \textit{k} most visited tweets and sends them as the recommendation to the user \textit{u}. To generalize, SALSA outputs a  single ranked list of vertices on the right-hand side of the bipartite interaction graph.

\subsection{GraphJet Deployment}
\label{subsec:GraphJet-Deployment}
The deployment of GraphJet is shown in figure \ref{fig:graphJet-deployment}. Each node runs a GraphJet instance, and fault tolerance is guarantied by replication. A Kafka queue ingests the incoming edges inside each replica. According to the main paper, each GraphJet instance can hold up to 10$^9$ edges in less than 30 GB of RAM. Zookeeper is also used for service registry and discovery of each GraphJet instance.
\begin{figure}[!h]
	\centering
	\includegraphics[width=0.50\textwidth]{images/graphjet/graphJet-deployment}
	\caption{GraphJet deployment}
	\label{fig:graphJet-deployment}
\end{figure}

\subsection{Related work}
\label{subsec:graphjet-related-work}
GraphJet's predecessor, the "Who To Follow" (WTF) system \cite{goel2015follow, gupta2013wtf}, is the first recommender system that proposes to store an entire production-scale follower graph in memory on a single machine and run a personalized SALSA algorithm to compute recommendations. Contrary to GraphJet, WTF is not used in a real-time environment as recommendations are precomputed and stored in a DBMS daily. Systems like \cite{baluja2008video} use a novel random walk approache, called \emph{Adsorption}, on a user-video bipartite graph to generate personal video recommendations.


Pinterest's recommendation system Pixie \cite{eksombatchai2018pixie} is the closest project to GraphJet, also storing a bipartite graph in memory on a single instance. Unlike GraphJet and WTF, which use a personalized SALSA, they present a Pixie Random Walk algorithm that terminates early once the results start converging.
