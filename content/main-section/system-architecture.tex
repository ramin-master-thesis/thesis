\section{System Architecture}
\label{System Architecture}

I implemented and simulated the GraphJet architecture to evaluate and test the proposed approach of data partitioning. As explained in section \ref{sec:GraphJet}, GraphJet architecture consists of three main layers: Storage, Recommendation, API Endpoint. The same layer system inspires my prototype architecture. In this section, I go through the system architecture and the design decisions taken while creating this work. In the first subsection, I explain the single instance architecture. After that, the subsection describes the distributed architecture of the system. 


\subsection{Single Machine}
\label{subsec:single-machine}
The overall high level architecture of a single instance can be seen in figure \ref{fig:single-machine-architecture}. The worker (i.e., instance) receives a user-ID as its input and then yields a ranked list of recommendations (i.e., tweets). The detailed architecture of the single worker is shown in figure \ref{fig:single-machine-architecture-detailed}. Let's break down each component of the system and explain how each layer works.

\todo{Pack two figures into one figure with A and B}
\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.75\textwidth]{images/simple-worker.png}
	\caption{Single machine overall architecture}
	\label{fig:single-machine-architecture}
\end{figure}

\begin{figure}[!h]
	\centering
	\includegraphics[width=0.75\textwidth]{images/simple-worker-detailed.png}
	\caption{Single machine detailed architecture}
	\label{fig:single-machine-architecture-detailed}
\end{figure}

\subsubsection{Storage and index layer}
\label{subsub:storage-index-layer}
The single instance needs to maintain the dataset in for of a bipartite graph in memory. A bipartite graph is a graph whose vertices can be divided into two disjoint and independent sets U and V such that every edge connects a vertex in U to one in V. The bipartite graph consists of two indices. One index stores all tweets for a specific user. The other index stores all users for a specific tweet.

\begin{table}[!h]
	\centering
	\caption{Simple indexing example}
	\label{tab:simple-indexing}
	\begin{tabular}{|l|c|}
		\hline
		\textbf{Key} & \textbf{Adjacency List} \\
		\hline
		5 & [200, 50] \\
		\hline
		12 & [60, 120, 60] \\
		\hline
		... & ... \\
		\hline
	\end{tabular}
\end{table}


GraphJet uses mutable (hot) and immutable (cold) index segments to store the bipartite graph \cite{sharmaGraphJetRealtimeContent2016}. With this approach, GraphJet optimizes newly incoming edge insertion. In this work, I assume that the system is not ingesting any edges during its runtime. Therefore, there is no need to optimize the prototype for insertion. To keep the indexing as simple as possible, I decided to use a \emph{simple index} system. This approach uses a single node-ID (user-ID or tweet-ID) as its index key. The index key points to an adjacency list containing the node-IDs that the index key interacts with. Table \ref{tab:simple-indexing} shows a small example of this approach. The node-ID 5 has interactions with node-IDs 200 and 50. The prototype generates two of these indices. First, using the user-IDs as its key and the tweet-IDs as the adjacency list values and vice versa.


\subsubsection{Recommendation layer}
\label{subsubsec:recommendation-layer}


\subsubsection{API Endpoint layer}
\label{subsubsec:api-endpoint-layer}


\subsection{Multiple Machines}
\label{Multiple Machines}

\begin{figure}[!h]
	\centering
	\includegraphics[width=1\textwidth]{images/multi-partition-architecture.png}
	\caption{Multiple partition architecture}
	\label{fig:multiple-machine-architecture}
\end{figure}

\todo{Improve this figure}
