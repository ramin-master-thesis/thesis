\section{System Architecture}
\label{sec:system-architecture}

I implemented and simulated the GraphJet architecture to evaluate and test the proposed approach of data partitioning. As explained in section \ref{sec:GraphJet}, GraphJet architecture consists of three main layers: Storage, Recommendation, API Endpoint. The same layer system inspires my prototype architecture. In this section, I go through the system architecture and the design decisions taken while creating this work. In the first subsection, I explain the single instance architecture. After that, the subsection describes the distributed architecture of the system. The implemented system cab be found in the repository\footnote{\url{https://github.com/ramin-master-thesis/salsa}} .


\subsection{Single Machine}
\label{subsec:single-machine}
The overall high-level architecture of a single instance can be seen in figure \ref{fig:single-machine-architecture}. The worker (i.e., instance) receives a user-ID as its input and then yields a ranked list of recommendations (i.e., tweets). The detailed architecture of the single worker is shown in figure \ref{fig:single-machine-architecture-detailed}. Let's break down each component of the system and explain how each layer works.

\begin{figure}[!h]
    \centering
    \begin{subfigure}[b]{0.75\textwidth}
       \includegraphics[width=1\linewidth]{images/simple-worker.png}
       \caption{Single machine high level overview}
       \label{fig:single-machine-architecture} 
    \end{subfigure}
    
    \begin{subfigure}[b]{0.8\textwidth}
       \includegraphics[width=1\linewidth]{images/simple-worker-detailed.png}
       \caption{Single machine including each layer}
       \label{fig:single-machine-architecture-detailed}
    \end{subfigure}
    
    \caption {Architecture of single instance, (a) Receives a user-ID as input query and generates recommendations. (b) More detailed view of each layer of a single worker. The layers consist of: Indexer, Recommender, and API Endpoint.}
\end{figure}


\todo{Add UML Diagram of Indexer and Recommender and API Endpoint to see the dependency between the modules}

\subsubsection{Storage and index layer}
\label{subsub:storage-index-layer}
The single instance needs to maintain the dataset in for of a bipartite graph in memory. A bipartite graph is a graph whose vertices can be divided into two disjoint and independent sets U and V such that every edge connects a vertex in U to one in V. The bipartite graph consists of two indices. One index stores all tweets for a specific user. The other index stores all users for a particular tweet.

\begin{table}[!h]
    \centering
    \caption{Simple indexing example}
    \label{tab:simple-indexing}
    \begin{tabular}{|l|c|}
        \hline
        \textbf{Key} & \textbf{Adjacency List} \\
        \hline
        5 & [200, 50] \\
        \hline
        12 & [60, 120, 60] \\
        \hline
        ... & ... \\
        \hline
    \end{tabular}
\end{table}


GraphJet uses mutable (hot) and immutable (cold) index segments to store the bipartite graph \cite{sharmaGraphJetRealtimeContent2016}. With this approach, GraphJet optimizes newly incoming edge insertion. In this work, I assume that the system is not ingesting any edges during its runtime. Therefore, there is no need to optimize the prototype for insertion. To keep the indexing as simple as possible, I decided to use a \emph{simple index} system. This approach uses a single node-ID (user-ID or tweet-ID) as its index key. The index key points to an adjacency list containing the node-IDs that the index key interacts with. Table \ref{tab:simple-indexing} shows a small example of this approach. The node-ID 5 has interactions with node-IDs 200 and 50. The prototype generates two of these indices. First, using the user-IDs as its key and the tweet-IDs as the adjacency list values and vice versa.


\subsubsection{Recommendation layer}
\label{subsubsec:recommendation-layer}
An implementation of the SALSA \cite{lempelSALSAStochasticApproach2001} algorithm lives in the recommendation layer. The algorithm needs a couple of parameters to start the random walk. These parameters are described in table \ref{tab:salsa-parameters}.


\begin{table}[!h]
    \centering
    \caption{SALSA algorithm parameters}
    \label{tab:salsa-parameters}
    \begin{tabular}{|l|c|}
        \hline
        \textbf{Parameter} & \textbf{Description} \\
        \hline
        Root node & ID of the starting node \\
        \hline
        Limit & Number of items to return \\
        \hline
        Walks & Number of random SALSA walks \\
        \hline
        Walks length & Length of the walks \\
        \hline
        Reset probability & Probability to start from the root node \\
        \hline
        Indexer & An implementation of the indexer  \\
        \hline
    \end{tabular}
\end{table}


The recommendation layer interacts with both the indexer and the API endpoint. The API endpoint layer calls the recommender layer and injects the necessary parameters to start the random walk. As explained before, the indexer builds two indices: left-index and right-index. The algorithm needs to ask each index to walk on the bipartite graph. The recommender calls the left index from the indexer to receive the adjacency list and then chooses one ID randomly. After selecting the node ID, the recommender asks the right side index for the next adjacency list. This process continues until the number of walks reaches its limit. Finally, the recommender sorts the visited nodes by their visit count and cut-offs the returned list by the limit it was passed to.


According to the main paper of GraphJet, the random walk always starts from a vertex located on the left index \cite{sharmaGraphJetRealtimeContent2016}. Concretely for the GraphJet use-case at Tweeter, the SALSA algorithm starts from the requested user-ID node on the left index and then walks to the tweet-ID on the right index. This work extends the SALSA algorithm. Instead of starting from the left side, the algorithm initiates from a node on the right side. The output is a list of right-side vertices (i.e., tweet-IDs). With this approach, the random walk produces related items to the initial node. The method is used to create train data for the StarSpace model (see section \ref{Generating Training Data}).

\subsubsection{API Endpoint layer}
\label{subsubsec:api-endpoint-layer}
The API endpoint layer provides an interface to interact with the system. The API endpoint layer interacts with the recommendation layer and receives the list of recommendations. This module jsonifies the ranked list and sends them back to the user. 

\subsection{Multiple Machines}
\label{Multiple Machines}
This section explains the multi-instance architecture. Figure \ref{fig:multiple-machine-architecture} shows the high-level architecture of the multi-instance design. Each instance (i.e., worker) is a single machine, explained in the previous subsection. Each worker receives an identifier at the time they are deployed in the cluster. When the instance is running, they load and index the sharded data they receive from the \emph{partitioner} module. The section \ref{sec:partitioning} explains this module in detail. 



\begin{figure}[!h]
	\centering
	\includegraphics[width=1\textwidth]{images/multi-partition-workers.png}
	\caption{Multiple instance architecture}
	\label{fig:multiple-machine-architecture}
\end{figure}


Each worker's API endpoint module receives an incoming query. Next, the workers check if the requested user-ID exists in the left index. If so, they compute the recommendations by starting the random SALSA walk. In the end step, the recommendations of each worker are sent to the \emph{data fusion} module, and depending on the method (explained in section \ref{sec:data-fusion-approaches}) used in that module, a single ranked list gets produced.

